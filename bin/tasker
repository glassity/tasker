#!/usr/bin/env ruby

require_relative '../lib/google_tasks_client'
require_relative '../lib/interactive_mode'
require 'thor'

class TaskerCLI < Thor
  class_option :credentials, type: :string, default: 'oauth_credentials.json', 
               desc: 'Path to OAuth credentials file'

  def initialize(*args)
    super
    @client = nil
  end

  desc 'login', 'Authenticate with Google OAuth'
  def login
    puts "Initiating OAuth login..."
    # Create client with force reauth to show login process
    @client = GoogleTasksClient.new(options[:credentials])
    @client.send(:authenticate, true)  # Force reauth to show the process
    puts "Successfully authenticated! You can now use other commands."
  rescue => e
    puts "Login failed: #{e.message}"
  end

  desc 'logout', 'Clear stored authentication tokens'
  def logout
    client.logout
  rescue => e
    puts "Logout failed: #{e.message}"
  end

  desc 'interactive', 'Start interactive mode'
  option :demo, type: :boolean, default: false, desc: 'Run in demo mode (for testing without TTY)'
  def interactive
    begin
      interactive_mode = InteractiveMode.new(client)
      if options[:demo]
        interactive_mode.demo
      else
        interactive_mode.start
      end
    rescue => e
      puts "Interactive mode failed: #{e.message}"
      puts "Please ensure you're running this in a proper terminal."
      puts "Use --demo flag to see a demonstration."
      puts e.backtrace.first(3) if ENV['DEBUG']
    end
  end

  desc 'lists', 'Show all task lists'
  option :limit, type: :numeric, desc: 'Maximum number of lists to show'
  def lists
    task_lists = client.list_task_lists(max_results: options[:limit])
    if task_lists.empty?
      puts 'No task lists found.'
    else
      puts "Task Lists (#{task_lists.length} total):"
      task_lists.each do |list|
        puts "  #{list.id}: #{list.title}"
      end
    end
  rescue => e
    puts "Error: #{e.message}"
  end

  desc 'create-list TITLE', 'Create a new task list'
  def create_list(title)
    list = client.create_task_list(title)
    puts "Created task list: #{list.title} (ID: #{list.id})"
  rescue => e
    puts "Error: #{e.message}"
  end

  desc 'delete-list LIST_ID', 'Delete a task list'
  def delete_list(list_id)
    client.delete_task_list(list_id)
    puts "Deleted task list: #{list_id}"
  rescue => e
    puts "Error: #{e.message}"
  end

  desc 'tasks LIST_ID', 'Show tasks in a list'
  option :completed, type: :boolean, default: false, desc: 'Show completed tasks'
  option :limit, type: :numeric, desc: 'Maximum number of tasks to show'
  def tasks(list_id)
    tasks = client.list_tasks(list_id, show_completed: options[:completed], max_results: options[:limit])
    if tasks.empty?
      puts 'No tasks found.'
    else
      puts "Tasks (#{tasks.length} total):"
      tasks.each_with_index do |task, index|
        display_task_summary(task, index + 1)
      end
    end
  rescue => e
    puts "Error: #{e.message}"
  end

  desc 'show TASK_ID', 'Show full task details'
  def show(task_id)
    # We need list context for this, so let's find the task across all lists
    task_lists = client.list_task_lists
    found_task = nil
    found_list = nil
    
    task_lists.each do |list|
      tasks = client.list_tasks(list.id, show_completed: true)
      task = tasks.find { |t| t.id == task_id }
      if task
        found_task = task
        found_list = list
        break
      end
    end
    
    if found_task
      display_task_full(found_task, found_list)
    else
      puts "Task not found: #{task_id}"
    end
  rescue => e
    puts "Error: #{e.message}"
  end

  desc 'create-task LIST_ID TITLE', 'Create a new task'
  option :notes, type: :string, desc: 'Task notes'
  option :due, type: :string, desc: 'Due date (YYYY-MM-DD)'
  def create_task(list_id, title)
    due_date = options[:due] ? "#{options[:due]}T00:00:00.000Z" : nil
    task = client.create_task(list_id, title, notes: options[:notes], due: due_date)
    puts "Created task: #{task.title} (ID: #{task.id})"
  rescue => e
    puts "Error: #{e.message}"
  end

  desc 'complete-task LIST_ID TASK_ID', 'Mark a task as completed'
  def complete_task(list_id, task_id)
    client.complete_task(list_id, task_id)
    puts "Completed task: #{task_id}"
  rescue => e
    puts "Error: #{e.message}"
  end

  desc 'delete-task LIST_ID TASK_ID', 'Delete a task'
  def delete_task(list_id, task_id)
    client.delete_task(list_id, task_id)
    puts "Deleted task: #{task_id}"
  rescue => e
    puts "Error: #{e.message}"
  end

  desc 'update-task LIST_ID TASK_ID', 'Update a task'
  option :title, type: :string, desc: 'New title'
  option :notes, type: :string, desc: 'New notes'
  option :due, type: :string, desc: 'New due date (YYYY-MM-DD)'
  def update_task(list_id, task_id)
    due_date = options[:due] ? "#{options[:due]}T00:00:00.000Z" : nil
    client.update_task(list_id, task_id, 
                       title: options[:title], 
                       notes: options[:notes], 
                       due: due_date)
    puts "Updated task: #{task_id}"
  rescue => e
    puts "Error: #{e.message}"
  end

  private

  def client
    @client ||= GoogleTasksClient.new(options[:credentials])
  end

  def display_task_summary(task, number)
    status_icon = task.status == 'completed' ? '✓' : '○'
    
    # Truncate title if longer than 75 characters
    title = task.title.length > 75 ? "#{task.title[0..74]}... +More" : task.title
    
    puts "  #{number}. #{status_icon} #{title}"
    
    # Show notes in brackets format, truncated
    if task.notes && !task.notes.empty?
      notes = task.notes.length > 75 ? "#{task.notes[0..74]}... +More" : task.notes
      puts "     [#{notes}]"
    end
    
    # Show due date if present
    puts "     Due: #{task.due}" if task.due
    puts
  end

  def display_task_full(task, list = nil)
    status_icon = task.status == 'completed' ? '✓' : '○'
    
    puts "#{status_icon} #{task.title}"
    puts "ID: #{task.id}"
    puts "List: #{list.title}" if list
    puts "Status: #{task.status}"
    puts "Due: #{task.due}" if task.due
    puts
    if task.notes && !task.notes.empty?
      puts "Notes:"
      puts task.notes
    end
  end
end

TaskerCLI.start(ARGV)